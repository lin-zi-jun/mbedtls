数字签名作用
数字签名是为了识别消息是否被篡改并验证消息可靠性，也可以防止否认。
这里注意下和消息验证码的不同，数字签名还可以防止否认，
因为数字签名的私钥只有签名者才持有，而消息认证码中的密钥是双方都有。
mnedtls中的数字签名有3种，RSA、DSA、ECDSA

RSA数字签名
RSA数字签名是基于RSA密钥系统，主要步骤如下

Alice生成RSA密钥对
Alice将公钥发送给Bob，自己保留私钥
Alice使用私钥对消息进行加密签名，并将加密后的消息和签名结果发送给Bob
Bob使用RSA公钥对消息进行解密，并算出摘要，判断消息是否又被篡改。

RSA数字签名填充方法
与RSA加解密部分类似，RSA数字签名也有2种填充方案：
PKCS1-v1_5
PSS

DSA数字签名
DSA算法是数字签名标准规范DSS（Digital Signature Standard）的一部分，
与RSA不同，DSA算法只能提供数字签名功能，而不能用于加密或密钥交换

步骤如下

Alice生成密钥，其中私钥（x），公钥（p，q，g，y），
其中素数p的长度位数为L位，q的长度位数为N位，则签名长度见下表

Alice用DSA签名结果有2部分r和s 记（r,s）
Bob用公钥、Alice发来的消息、和（r，s）验签判断是否通过。
这里只能得到一个是否通过的结果不能用于加密或密钥交换。

ECDSA数子签名
ECDSA就是再DSA基础上加上椭圆曲线算法，和ECDH与DH的关系一样，
用较短的密钥长度便可以提供与RSA和DSA算法相同的安全等级，步骤如下

ECDSA生成密钥对
Alice密钥对的生成依赖椭圆曲线参数，常用的有secp256r1和secp384r1，
椭圆曲线参数有（p，a，b，G，n，h）。得到私钥（d），公钥（p，a，b，G，Q）

ECDSA签名
Alice ECDSA签名结果为r和s，记做（r，s），其中r和s的长度与n相同，
例如再escp256r1中，n长度位256比特，则r和s也是256比特

ECDSA验签
Bob在拿到公钥、消息、以及（r，s）后验签判断是否通过。
这里只能得到一个是否通过的结果不能用于加密或密钥交换。


数字证书原理
数字证书又称公钥证书或身份证书，目的是为了解决密钥分发问题，因为虽然有了公钥算法和数字签名算法，
但是如果攻击者将公钥都替换掉则不能验证对方身份。所以才有数字证书的出现，数字证书主要包含公钥信息、用户身份信息、
来自发行者的数字签名。数字证书的基础是认为CA机构具有公信力，无条件相信CA机构。下面是数字证书签发流程

1.Bob生成密钥对，即Bob的公钥和私钥
2.Bob用公钥以及Bob本身的相关信息比如地址域名等信息生成证书签名请求（CSR），并把其发送给证书认证机构CA
3.CA在经过调查后认为Bob发来的CSR信息是真实的就会给Bob颁发证书，证书中主要包括Bob的公钥和数字签名
4.当Alice要和Bob通讯时，Bob就会把证书发送给Alice。
5.Alice从CA获得CA根证书来解密Bob发来的证书，验证数字签名是否一致来判断Bob的真实性。
6.并且以后Alice发送的消息可以用Bob的公钥加密后发送。




SSL/TLS协议流程

RSA加密
属于非对称加密，特点是若明文信息被公钥加密成密文，则密文只能被私钥解密；若明文信息被私钥加密成密文，则密文只能被公钥解密

CA
你可以理解成，只要是CA信任的组织，你就信任，CA也有自己的公钥、私钥。CA的公钥是众所周知的。

证书和签名
证书包含有：申请者的公钥、申请者的组织信息、签名。
这里可以看出证书是包含签名的，那签名是怎么产生的呢？

把申请者的公开信息用散列函数计算出一个信息摘要，然后用CA的私钥把这个信息摘要进行加密，这个密文就是签名。

如果证书内容被修改，比如证书里面的公钥，收到证书的一方计算证书的信息摘要后发现与在用CA的公钥解密证书签名后得到的
信息摘要后不一致，就能判断证书被修改。

还有一些常用命名
1.比如server生成的私钥/公钥对，可以命名成server.key/server.pub
2.CA给server颁发的证书可以命名成server.crt
3.CA也有自己的证书，可以命名成ca.crt(里面有CA公钥)

单向认证
通常是client来验证server的合法性，所以client就需要一个ca.crt(用来验证server.crt),server需要server.crt，server.key

双向认证
在单向认证基础上，服务器还要验证客户端合法性
server需要server.key，server.crt，ca.crt
client 需要 client.key 、client.crt 、ca.crt

知道上面几点后就好理解了

第一步，客户端发出请求（ClientHello）
包含以下信息：

client支持的协议ssl协议版本
client生成一个随机数
支持的加密方法、压缩方法
第二步，服务端发出请求（ServerHello）
包含以下信息：

确认使用的ssl协议版本
server生成一个随机数
确认使用的加密方法、压缩方法
服务器证书
如果是双向认证，这里服务端还会请求客户端的证书

第三步，客户端回应
client收到server.crt后用ca.crt来验证server的合法性，如果不合法，会显示一个警告，让访问者选择是否还要继续访问
（你要继续访问也是可以的）。如果合法，client就从证书里取出server的公钥，然后：

生成一个随机数（注意这是client生成的第二个随机数，又称“pre-master key”），若是单向认证，则用server公钥加密这个随机数，
若是双向认证，则先用client端私钥加密这个随机数，在把加密后的密文用server公钥再加密一个，也就是加密了2次。
编码改变通知，意思就是之后发送的信息是通过会话秘钥加密后的
客户端握手结束通知，也包含前面所有内容hash，用于给服务器校验
如果是双向认证，客户端是在这一步发送客户端证书给服务器

第四步，服务器最后回应
服务器在收到加密后的第三个随机数后，用自己的私钥解密，如果是双向认证，还要用客户端公钥解密，得到pre-master key。然后：

编码改变通知，意思就是之后发送的信息是通过会话秘钥加密后的
客户端握手结束通知，也包含前面所有内容hash，用于给客户端校验
第三步、第四步提到的会话秘钥是由第一、二、三步产生的随机数通过双方事先商定好的秘钥生成机制生成出对称秘钥，
之后在本次回话中双方都是用这个对称秘钥来加密解密信息。











TLS框架
TLS是一种加密通讯框架，有下面3个阶段

密钥交换阶段，伪随机数生成、ECDH、ECDSA、RSA、还有X509证书
密钥计算阶段，HMAC算法，如HMAC-256
对称加密阶段，AES算法和HMAC算法，AES-CBC、AES-GCM、HMAC-256等
TLS密码套件
通讯双方需要有相同的密码运算能力才能完成密钥交换和消息加密解密。IANA规定了多种密码套件（Cipher Suite），
通讯双方根据约定好的密码套件进行加密。密码套件由密钥协商算法、身份认证算法、对称加密算法、消息认证码和伪随机数组成

TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384
密钥协商算法 ECDHE
身份认证算法 ECDSA
对称加密算法 AES_256
消息认证算法 GCM
伪随机数算法 SHA384

TLS_PSK_WITH_AES_128_CBC_SHA256
密钥协商算法 PSK
身份认证算法 无
对称加密算法 AES_128_CBC
消息认证算法 HMAC_SHA256
伪随机数算法 HMAC_SHA256

TLS_RSA_WITH_AES_128_CBC_SHA256
密钥协商算法 RSA
身份认证算法 RSA
对称加密算法 AES_128_CBC
消息认证算法 HMAC_SHA256
伪随机数算法 HMAC_SHA256

TLS_DHE_RSA_WITH_AES_128_CBC_SHA256
密钥协商算法 DHE
身份认证算法 RSA
对称加密算法 AES_128_CBC
消息认证算法 HMAC_SHA256
伪随机数算法 HMAC_SHA256

握手过程
这里理解大概流程https://blog.csdn.net/weixin_41572450/article/details/84112992


PSK密钥交换
可以看到密码套件有一个TLS_PSK_WITH_AES_128_CBC_SHA256这种就是采用PSK密钥交换，不是用X.509证书交换。
对于互联网来说1k多的证书毫无压力，但是对于嵌入式设备来说，希望减小传输开销，PSK就是这个目的。
当然只有在客户端和服务器都支持才能使用。

PSK Identity 和 PSK
PSK Identity 和 PSK其实就是类似用户名和登录密钥概念，PSK Identity 常用字符串表示，如出厂编号、
CPUID等信息，PSK一般采用Hex格式表示。不同的设备PSK Identity 和 PSK不同。当客户端告知服务器自身的PSK Identity 后，
服务器根据告知的PSK Identity 找到对应的PSK，拿这个PSK最作为第三个随机数即预设主密钥，结合前面的2个随机数生成对称密钥。
客户端也是这样。可以看到者中间少了证书传递的开销。

例子
下面是TLS单、双向认证客户端源码、相关证书生成脚本、TLS客户端、服务器创建脚本、wireshark抓包分析、客户端连接过程log。
https://download.csdn.net/download/weixin_41572450/12001752













概述
DTLS（Datagram Transport Layer Security）是运行在UDP之上的安全通讯协议，大部分和TLS是一样的，
只是针对UDP在不可靠传输问题增加了新特性，用来解决UDP传输的报文乱序和报文丢失等问题，DTLS主要通过下面方法来解决

禁止密码流，避免记录层报文前后关联
在记录层增加计数值和序列号字段，用于排序和数据确认
在握手子协议中加入重传机制，防止握手过程中报文丢失
在握手子协议中加入序列号，保证握手报文顺序正确
在握手协议中增加偏移量（fragment_offset）和帧长度（fragment_length）字段，
IP层会在报文长度大于1500分片，用这2个字段重组

DTLS握手协议变化
防止DDos攻击
握手子协议中加入HelloVerifyRequest，服务器收到ClientHello后将会为客户端分配一个cookie，
并把这个cookie包含在HelloVerifyRequest中，客户端在收到带有cookie的ClientHello后，需要重新发ClientHello。
如果服务器在短时间内收到某个IP重复报文则会丢弃。

