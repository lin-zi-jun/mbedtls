数字签名作用
数字签名是为了识别消息是否被篡改并验证消息可靠性，也可以防止否认。
这里注意下和消息验证码的不同，数字签名还可以防止否认，
因为数字签名的私钥只有签名者才持有，而消息认证码中的密钥是双方都有。
mnedtls中的数字签名有3种，RSA、DSA、ECDSA

RSA数字签名
RSA数字签名是基于RSA密钥系统，主要步骤如下

Alice生成RSA密钥对
Alice将公钥发送给Bob，自己保留私钥
Alice使用私钥对消息进行加密签名，并将加密后的消息和签名结果发送给Bob
Bob使用RSA公钥对消息进行解密，并算出摘要，判断消息是否又被篡改。

RSA数字签名填充方法
与RSA加解密部分类似，RSA数字签名也有2种填充方案：
PKCS1-v1_5
PSS

DSA数字签名
DSA算法是数字签名标准规范DSS（Digital Signature Standard）的一部分，
与RSA不同，DSA算法只能提供数字签名功能，而不能用于加密或密钥交换

步骤如下

Alice生成密钥，其中私钥（x），公钥（p，q，g，y），
其中素数p的长度位数为L位，q的长度位数为N位，则签名长度见下表

Alice用DSA签名结果有2部分r和s 记（r,s）
Bob用公钥、Alice发来的消息、和（r，s）验签判断是否通过。
这里只能得到一个是否通过的结果不能用于加密或密钥交换。

ECDSA数子签名
ECDSA就是再DSA基础上加上椭圆曲线算法，和ECDH与DH的关系一样，
用较短的密钥长度便可以提供与RSA和DSA算法相同的安全等级，步骤如下

ECDSA生成密钥对
Alice密钥对的生成依赖椭圆曲线参数，常用的有secp256r1和secp384r1，
椭圆曲线参数有（p，a，b，G，n，h）。得到私钥（d），公钥（p，a，b，G，Q）

ECDSA签名
Alice ECDSA签名结果为r和s，记做（r，s），其中r和s的长度与n相同，
例如再escp256r1中，n长度位256比特，则r和s也是256比特

ECDSA验签
Bob在拿到公钥、消息、以及（r，s）后验签判断是否通过。
这里只能得到一个是否通过的结果不能用于加密或密钥交换。


数字证书原理
数字证书又称公钥证书或身份证书，目的是为了解决密钥分发问题，因为虽然有了公钥算法和数字签名算法，
但是如果攻击者将公钥都替换掉则不能验证对方身份。所以才有数字证书的出现，数字证书主要包含公钥信息、用户身份信息、
来自发行者的数字签名。数字证书的基础是认为CA机构具有公信力，无条件相信CA机构。下面是数字证书签发流程

1.Bob生成密钥对，即Bob的公钥和私钥
2.Bob用公钥以及Bob本身的相关信息比如地址域名等信息生成证书签名请求（CSR），并把其发送给证书认证机构CA
3.CA在经过调查后认为Bob发来的CSR信息是真实的就会给Bob颁发证书，证书中主要包括Bob的公钥和数字签名
4.当Alice要和Bob通讯时，Bob就会把证书发送给Alice。
5.Alice从CA获得CA根证书来解密Bob发来的证书，验证数字签名是否一致来判断Bob的真实性。
6.并且以后Alice发送的消息可以用Bob的公钥加密后发送。




SSL/TLS协议流程

RSA加密
属于非对称加密，特点是若明文信息被公钥加密成密文，则密文只能被私钥解密；若明文信息被私钥加密成密文，则密文只能被公钥解密

CA
你可以理解成，只要是CA信任的组织，你就信任，CA也有自己的公钥、私钥。CA的公钥是众所周知的。

证书和签名
证书包含有：申请者的公钥、申请者的组织信息、签名。
这里可以看出证书是包含签名的，那签名是怎么产生的呢？

把申请者的公开信息用散列函数计算出一个信息摘要，然后用CA的私钥把这个信息摘要进行加密，这个密文就是签名。

如果证书内容被修改，比如证书里面的公钥，收到证书的一方计算证书的信息摘要后发现与在用CA的公钥解密证书签名后得到的
信息摘要后不一致，就能判断证书被修改。

还有一些常用命名
1.比如server生成的私钥/公钥对，可以命名成server.key/server.pub
2.CA给server颁发的证书可以命名成server.crt
3.CA也有自己的证书，可以命名成ca.crt(里面有CA公钥)

单向认证
通常是client来验证server的合法性，所以client就需要一个ca.crt(用来验证server.crt),server需要server.crt，server.key

双向认证
在单向认证基础上，服务器还要验证客户端合法性
server需要server.key，server.crt，ca.crt
client 需要 client.key 、client.crt 、ca.crt

知道上面几点后就好理解了

第一步，客户端发出请求（ClientHello）
包含以下信息：

client支持的协议ssl协议版本
client生成一个随机数
支持的加密方法、压缩方法
第二步，服务端发出请求（ServerHello）
包含以下信息：

确认使用的ssl协议版本
server生成一个随机数
确认使用的加密方法、压缩方法
服务器证书
如果是双向认证，这里服务端还会请求客户端的证书

第三步，客户端回应
client收到server.crt后用ca.crt来验证server的合法性，如果不合法，会显示一个警告，让访问者选择是否还要继续访问
（你要继续访问也是可以的）。如果合法，client就从证书里取出server的公钥，然后：

生成一个随机数（注意这是client生成的第二个随机数，又称“pre-master key”），若是单向认证，则用server公钥加密这个随机数，
若是双向认证，则先用client端私钥加密这个随机数，在把加密后的密文用server公钥再加密一个，也就是加密了2次。
编码改变通知，意思就是之后发送的信息是通过会话秘钥加密后的
客户端握手结束通知，也包含前面所有内容hash，用于给服务器校验
如果是双向认证，客户端是在这一步发送客户端证书给服务器

第四步，服务器最后回应
服务器在收到加密后的第三个随机数后，用自己的私钥解密，如果是双向认证，还要用客户端公钥解密，得到pre-master key。然后：

编码改变通知，意思就是之后发送的信息是通过会话秘钥加密后的
客户端握手结束通知，也包含前面所有内容hash，用于给客户端校验
第三步、第四步提到的会话秘钥是由第一、二、三步产生的随机数通过双方事先商定好的秘钥生成机制生成出对称秘钥，
之后在本次回话中双方都是用这个对称秘钥来加密解密信息。